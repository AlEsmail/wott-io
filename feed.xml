<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="https://wott.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://wott.io/" rel="alternate" type="text/html" /><updated>2019-08-14T16:25:06+00:00</updated><id>https://wott.io/feed.xml</id><title type="html">Web of Trusted Things</title><subtitle>WoTT is a free, automated, open-source public key infrastructure for connected hardware</subtitle><entry><title type="html">IoT Security Issues and Challenges</title><link href="https://wott.io/blog/news/thoughts/2019/08/12/iot-security-Issues-and-challenges" rel="alternate" type="text/html" title="IoT Security Issues and Challenges" /><published>2019-08-12T13:00:00+00:00</published><updated>2019-08-12T13:00:00+00:00</updated><id>https://wott.io/blog/news/thoughts/2019/08/12/iot-security-Issues-and-challenges</id><content type="html" xml:base="https://wott.io/blog/news/thoughts/2019/08/12/iot-security-Issues-and-challenges">&lt;p&gt;&lt;img alt=&quot;IoTSecurityIssues&quot; src=&quot;https://wott.io/assets/blog/IoTSecIssues-Blog-d205b55b946e45a78176837a366f236d57bf5c24bec05c34900905fddf41c17e.png&quot; integrity=&quot;sha256-0gW1W5RuRaeBdoN6Nm8jbVe/XCS+wFw0kAkF/d9BwX4=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/9bf085-129c69c3bbdee7ba8610847e32b45a7ba23ff3b3100565fa99f051a54eccc19f.png 2x, https://wott.io/assets/4b94b4-ea1277f2567ad07bc6cccc7cea996387bc8097002634f242ae5675603bac7f2a.png 1x&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;iot-security-issues-and-challenges&quot;&gt;IoT Security Issues and Challenges&lt;/h2&gt;
&lt;p&gt;IoT Security issues are quite a challenge for this burgeoning industry. There is a growing number of devices, applications and systems which turn to IoT. This helps them to upscale their efficiency and their services and to make life easier for users. So let us take a closer look at the industry.&lt;/p&gt;

&lt;h3 id=&quot;the-internet-of-things&quot;&gt;The Internet of Things&lt;/h3&gt;
&lt;p&gt;This buzzing, new industry sports cutting-edge technology. It enhances digitisation while at the same time it produces demanding challenges.
But before we delve into these in more detail, let us have a look at the state of IoT at the moment.&lt;/p&gt;

&lt;p&gt;According to a report by [IoT Analytics] (https://iot-analytics.com/state-of-the-iot-update-q1-q2-2018-number-of-iot-devices-now-7b/) there are over 17 Billion devices connected to IoT. As one can understand, this number will only multiply in the coming years. The devices connected to IoT range greatly.  From Smart Home Automation devices, routers, printers to thermostats, refrigerators and cameras. Amazon Alexa and Google Assistant too. Smart locks, smart watches, ATMs, industrial machines, manufacturing processes and applications. Smart clothing items, drones, solar panels, automobile navigation, infotainment systems, advanced medical devices.  The list is long and it is updated as more types of devices, gadgets and applications are added.&lt;/p&gt;

&lt;p&gt;Regardless of the technology or the number  of IoT devices, the main challenge remains one: That is &lt;em&gt;Security&lt;/em&gt; and everything about it.&lt;/p&gt;

&lt;h2 id=&quot;iot-security-issues&quot;&gt;IoT Security Issues&lt;/h2&gt;

&lt;h3 id=&quot;unsecured-devices&quot;&gt;Unsecured Devices&lt;/h3&gt;
&lt;p&gt;With the number of connected devices on the rise, consumers play an integral part in Security. Manufacturers upon launching a device, should equip it with a strong default password. They should also advise consumers on how to make their lives with smart gadgets more secure. Most consumers are not well-informed about the significance of changing the default password on their devices. Thus, the responsibility falls on the manufacturers to maintain a more secure network and to educate the consumers of the necessary steps they need to take.&lt;/p&gt;
&lt;h3 id=&quot;data-privacy&quot;&gt;Data Privacy&lt;/h3&gt;
&lt;p&gt;Nowadays, power plants, manufacturing processes and healthcare devices connect to IoT. These critical infrastructures constitute IoT a treasure trove of data. One mistake in security and precious confidential data might end up in the hands of criminals.  One leak in Privacy and hackers can gain access to confidential, private data. Data transmission and reception as well as maintaining the privacy of the users must be a top priority of the IoT industry. With so many applications, gadgets and processes connected, even lives can be at stake. This is one of the reasons why [Security-by-design] (https://wott.io/blog/thoughts/2019/06/25/why-open-source-solutions-are-critical-for-IoT) is a great solution, particularly  for Enterprise IoT.&lt;/p&gt;

&lt;h3 id=&quot;insufficient--testing-and-updating&quot;&gt;Insufficient  Testing and Updating&lt;/h3&gt;
&lt;p&gt;As the number of connected devices is in constant rise, one of the major IoT security issues is keeping the devices updated. Though IoT is a highly-digitised industry, it is amazing to see that the devices used, do not receive many updates.  All the gadgets, applications and devices need to be sufficiently tested before launched. Then, they should be updated frequently, with patches and releases enhancing their security.&lt;/p&gt;
&lt;h3 id=&quot;iot-malware-and-ransomware&quot;&gt;IoT Malware and Ransomware&lt;/h3&gt;
&lt;p&gt;Some digitised appliances and some gadgets too, have the same computer power as a tablet. This means that they can be compromised, hijacked by hackers. Then, they can become a powerful weapon which hackers can use to compromise the system in many ways. At WoTT, we believe that IoT security is a complicated issue. It can not be achieved by obfuscation; on the contrary, it should be [Open-Source] (https://wott.io/blog/thoughts/2019/06/25/why-open-source-solutions-are-critical-for-IoT) where knowledge of operations is shared and put to good use.&lt;/p&gt;

&lt;p&gt;One of the ways IoT devices can be used by hackers is to cause DDoS attacks. Hackers hijack computers and add them to a network of malicious botnets conducting DDoS attacks. DDoS attacks result when multiple compromised systems flood the resources of a targeted system with traffic. Thus, as it is easy for computers to be hijacked and participate in a DDoS attack without the owner knowing, so are smart devices, appliances and gadgets too. They can be compromised and used by a hacker.&lt;/p&gt;

&lt;h3 id=&quot;so-what-can-go-wrong-with-iot-security-issues&quot;&gt;So what can go wrong with IoT Security issues?&lt;/h3&gt;
&lt;p&gt;Assuming that there is a compromise of some sort in an IoT device or gadget many things can go wrong. First, you may no longer have control of it - or &lt;em&gt;lose availability&lt;/em&gt;. This has a financial impact, of course. Yet, there are many other parameters and ways in which a hijacked device can affect you, your life and everything around it. Hackers may turn your IoT device into a spam machine sending spam emails to everyone - &lt;em&gt;damaging your reputation&lt;/em&gt;.  They can transmit false signals, such as a false battery charging report - &lt;em&gt;disrupting your operation&lt;/em&gt;.  Worse yet, hackers can compromise entire networks to interfere with entire manufacturing plants, energy grids or fleets of vehicles. What is truly scary is the potential for loss of life when thinking of medical devices or heavy machinery.&lt;/p&gt;

&lt;h3 id=&quot;a-solution-to-the-iot-security-issues&quot;&gt;A solution to the IoT security issues&lt;/h3&gt;
&lt;p&gt;We at WoTT aim at making the IoT industry a web of trusted devices, applications and gadgets. A place where security is of primary importance. WoTT is the go-to place as the network of connected devices grows.  Security, knowledge and collaboration between devices, manufacturers and developers is our philosophy. So, we bring to you a developer first [Solution] (https://wott.io/) to manage certificates and credentials, and find vulnerabilities in your build.&lt;/p&gt;</content><author><name>Nikoletta Triantafyllopoulou</name></author><category term="[&quot;news&quot;, &quot;thoughts&quot;]" /><category term="Open Source" /><summary type="html"></summary></entry><entry><title type="html">Using WoTT to Secure a Paho MQTT Client</title><link href="https://wott.io/blog/tutorials/2019/07/19/paho-mqtt" rel="alternate" type="text/html" title="Using WoTT to Secure a Paho MQTT Client" /><published>2019-07-19T13:00:00+00:00</published><updated>2019-07-19T13:00:00+00:00</updated><id>https://wott.io/blog/tutorials/2019/07/19/paho-mqtt</id><content type="html" xml:base="https://wott.io/blog/tutorials/2019/07/19/paho-mqtt">&lt;h1 id=&quot;using-wott-to-secure-a-connection-from-a-paho-mqtt-client-to-an-mqtt-server-mosquitto-mqtt-example-included&quot;&gt;Using WoTT to Secure a Connection from a Paho MQTT Client to an MQTT Server (Mosquitto MQTT Example included)&lt;/h1&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In a previous &lt;a href=&quot;https://wott.io/blog/tutorials/2019/07/15/mosquitto-mqtt&quot;&gt;example&lt;/a&gt; we discussed how to secure connections between an Mosquitto MQTT broker and the Mosquitto client. In that there are several different brokers for an MQTT brokers, there are also several client implementations for the MQTT protocol. There are several libraries available for multiple MQTT clients in various programming languages. This example looks at Paho, a project that was adopted into the Eclipse Foundation much like Mosquitto, that specifically implements a client for MQTT. We will be looking at the Python implementation of Paho. Although you can use any other MQTT server, we already have a Mosquitto server from our previous example that we can use for this tutorial.&lt;/p&gt;

&lt;p&gt;Here we will show how simple it is to secure a Mosquitto server and a non-Mosquitto client (Paho) using WoTT. The principles shown here can be applied to any MQTT client accessing a Mosquitto server.&lt;/p&gt;

&lt;p&gt;You will need two devices, either a Debian machine or Raspberry Pi. In a set up where you have both, it is preferable to set up the Debian machine as your server device. Both these devices will need to have the &lt;a href=&quot;https://wott.io/documentation/getting-started&quot;&gt;WoTT Agent&lt;/a&gt; installed and &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/debian/&quot;&gt;Docker CE&lt;/a&gt; installed. Note installation instructions for Docker on Pi is different so refer to the link above for appropriate instructions.&lt;/p&gt;

&lt;p&gt;This example contains code snippets. We recommend you clone our &lt;a href=&quot;https://github.com/WoTTsecurity/examples&quot;&gt;examples&lt;/a&gt; repository by doing the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/WoTTsecurity/examples.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Alternatively, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; to manually install the files that you need. Refer to our other code snippet examples (&lt;a href=&quot;https://wott.io/blog/tutorials/2019/06/27/adafruit-io&quot;&gt;Adafruit IO&lt;/a&gt;, &lt;a href=&quot;https://wott.io/blog/tutorials/2019/06/16/simple-webapp&quot;&gt;Simple WebApp&lt;/a&gt;, etc) for instructions to do this. However, if you are going to be looking at our other tutorials in the future we recommend you have the repository readily available.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-the-server-mosquitto&quot;&gt;Setting up the server (Mosquitto)&lt;/h2&gt;

&lt;p&gt;Please refer to our &lt;a href=&quot;(https://wott.io/blog/tutorials/2019/07/15/mosquitto-mqtt)&quot;&gt;Mosquitto MQTT example&lt;/a&gt; for in depth information on how to set up the server. If you are familiar with this example and want to just quickly ‘set up and go,’ do the following:&lt;/p&gt;

&lt;p&gt;Navigate to the directory where you have cloned our ‘examples’ repository:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd examples/mosquitto-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Alter the ACL file &lt;code class=&quot;highlighter-rouge&quot;&gt;permissions.acl&lt;/code&gt; with your WoTT device details for the relevant permissions (remember we want to grant some access to your client device). To find the WoTT Device ID:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo wott-agent whoami
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We are still using the topic &lt;code class=&quot;highlighter-rouge&quot;&gt;/wott/temperature&lt;/code&gt; to publish and subscribe messages to and from.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-the-client-paho&quot;&gt;Setting up the client (Paho)&lt;/h2&gt;

&lt;p&gt;This is where our instructions differ from setting up the Mosquitto client. It is not significantly more complicated but Paho has a different set up. First, you will need to have Paho on your system.
Navigate to the directory containing our &lt;code class=&quot;highlighter-rouge&quot;&gt;examples&lt;/code&gt; respository. Navigate to the &lt;code class=&quot;highlighter-rouge&quot;&gt;paho-mqtt-client&lt;/code&gt; folder like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd examples
$ cd paho-mqtt-client
$ pip3 install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There are two files in this folder - a &lt;code class=&quot;highlighter-rouge&quot;&gt;requirements.txt&lt;/code&gt; file and the client itself &lt;code class=&quot;highlighter-rouge&quot;&gt;paho-connect-wott.py&lt;/code&gt;. The above command installs the version of the Paho client needed for this example.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; you can use whatever version of the &lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt; tool you have.&lt;/p&gt;

&lt;p&gt;Now that Paho is installed, you need to set your server variables for Paho to connect to. Do the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export MQTT_SERVER=ServerDeviceID.d.wott.local
$ export MQTT_TOPIC=my/topic
$ export MQTT_PORT=8333 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;where for this example &lt;code class=&quot;highlighter-rouge&quot;&gt;my/topic&lt;/code&gt; refers to the topic &lt;code class=&quot;highlighter-rouge&quot;&gt;wott/temperature&lt;/code&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;my/topic&lt;/code&gt; will default to &lt;code class=&quot;highlighter-rouge&quot;&gt;wott/temperature&lt;/code&gt; if not specified otherwise).&lt;/p&gt;

&lt;p&gt;Feel free to try and run the client now using &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo python3 paho-connect-wott.py&lt;/code&gt;. You will notice that this fails. 
This is because we haven’t established a route for the client to connect to the server device through - we need to alter the &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; file on the client to add a route to the server. In the Mosquitto example, we set this up using Docker, but here you will need to manually add the hostname. So, in whatever text editor you prefer:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo $EDITOR /etc/hosts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You will see a file containing something like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;127.0.0.1    localhost
127.0.1.1    your_machine's_name
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Add your server device’s IP followed by the ‘domain’ that you will be calling it by- the device’s WoTT ID (do not remove the other ones!) like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IP.Of.Docker.Server  ServerDeviceID.d.wott.local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Save and exit. Now you have a route to the server!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; we have discussed finding your IP in previous examples. There are several commands such as &lt;code class=&quot;highlighter-rouge&quot;&gt;ip addr show&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig&lt;/code&gt;, etc. Take your pick as long as you choose the &lt;code class=&quot;highlighter-rouge&quot;&gt;inet&lt;/code&gt; address for your server IP.&lt;/p&gt;

&lt;p&gt;Now we can run the client using Python 3. The output will look like the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo python3 paho-connect-wott.py
rc: 0
Subscribed: (1,0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you check your server, you will see that it has registered a connection from the Paho client.&lt;/p&gt;

&lt;h2 id=&quot;finishing-notes&quot;&gt;Finishing notes&lt;/h2&gt;

&lt;p&gt;You are now securely set up with a Paho MQTT client. The client accesses the server through the server’s CN (common name). This is how the client verifies the server (this is defined in our &lt;code class=&quot;highlighter-rouge&quot;&gt;mosquitto.conf&lt;/code&gt; file for the Mosquitto server if you can recall) unlike a typical browser where there is only one-way verification. You can essentially think of it as the client matching the server name to that which is one the ACL file (permissions).&lt;/p&gt;

&lt;p&gt;The example we provided contains a simple subscriber. Please experiment with a Paho publisher yourself and other clients. We want you to feel free to break our code! It’s the best way to develop.&lt;/p&gt;

&lt;p&gt;Hopefully you’ve now grasped the basic concepts of setting up at least two different types of MQTT server/client with the cryptographic identity that WoTT provides so you don’t actually need to worry about the details of the security itself.&lt;/p&gt;</content><author><name>Fiona McAllister</name></author><category term="tutorials" /><category term="Open Source" /><summary type="html">Using WoTT to Secure a Connection from a Paho MQTT Client to an MQTT Server (Mosquitto MQTT Example included)</summary></entry><entry><title type="html">Connecting Edge IoT devices with Kubernetes</title><link href="https://wott.io/blog/tutorials/2019/07/18/edge-to-kubernetes" rel="alternate" type="text/html" title="Connecting Edge IoT devices with Kubernetes" /><published>2019-07-18T08:00:00+00:00</published><updated>2019-07-18T08:00:00+00:00</updated><id>https://wott.io/blog/tutorials/2019/07/18/edge-to-kubernetes</id><content type="html" xml:base="https://wott.io/blog/tutorials/2019/07/18/edge-to-kubernetes">&lt;h1 id=&quot;bridging-edge-iot-devices-with-kubernetes&quot;&gt;Bridging Edge IoT devices with Kubernetes&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Required Skill Level&lt;/strong&gt;: Medium to Expert&lt;/p&gt;

&lt;p&gt;In my &lt;a href=&quot;https://wott.io/blog/tutorials/2019/07/15/mtls-with-nginx&quot;&gt;last blog post&lt;/a&gt;, we covered how to configure Nginx to use Mutual TLS (mTLS). This illustrated how mTLS can both simplify the back-end, while also make it more secure. In this article, we will take this one step further and integrate this with &lt;a href=&quot;https://kubernetes.io/&quot;&gt;Kubernetes&lt;/a&gt;. If you haven’t read the last blog post, that would be a good place to start.&lt;/p&gt;

&lt;p&gt;Please note that this article assumes that you are familiar with Kubernetes and understands the fundamentals.&lt;/p&gt;

&lt;h2 id=&quot;pre-requisites&quot;&gt;Pre-requisites&lt;/h2&gt;

&lt;p&gt;Before we dive into the actual configuration, we will assume that you have the following already configured:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A Kubernetes cluster (d’oh!)&lt;/li&gt;
  &lt;li&gt;A valid SSL certificate for your domain
    &lt;ul&gt;
      &lt;li&gt;You can use &lt;a href=&quot;https://github.com/jetstack/cert-manager/&quot;&gt;cert-manager&lt;/a&gt; from our friends at &lt;a href=&quot;https://www.jetstack.io/&quot;&gt;Jetstack&lt;/a&gt; if you want to use Let’s Encrypt&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;An &lt;a href=&quot;https://github.com/kubernetes/ingress-nginx&quot;&gt;Nginx Ingress Controller&lt;/a&gt; configured with the SSL certificate(s)
    &lt;ul&gt;
      &lt;li&gt;It is recommended that you use the &lt;a href=&quot;https://github.com/helm/charts/tree/master/stable/nginx-ingress&quot;&gt;Nginx Helm Chart&lt;/a&gt; for this&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Familiarity with &lt;a href=&quot;https://helm.sh/&quot;&gt;Helm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;getting-started&quot;&gt;Getting started&lt;/h2&gt;

&lt;p&gt;With the cluster and ingress controller up and running, you should be able to route traffic to your services. If you’re not familiar with this part, we recommend that you take a look at this Katacoda’s &lt;a href=&quot;https://www.katacoda.com/courses/kubernetes/create-kubernetes-ingress-routes&quot;&gt;Kubernetes Ingress training scenario&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Before proceeding further, we will assume that you now have an Nginx Ingress controller deployed, with some kind of service behind it that you can route traffic to in the ‘foobar’ namespace. In the example below, we will call this service ‘foobar,’ and it listens on port 80.&lt;/p&gt;

&lt;h2 id=&quot;configuring-mtls-for-the-ingress-controller&quot;&gt;Configuring mTLS for the Ingress Controller&lt;/h2&gt;

&lt;p&gt;Because the Nginx Ingress controller is already configured to support mTLS and subsequently does all the heavy-lifting, all we really need to do is to tell our Ingress object to use the built-in functionalities.&lt;/p&gt;

&lt;p&gt;Before we do this however, we first need to download the WoTT CA and upload this to the cluster. Otherwise Nginx will not be able to verify the certificate.&lt;/p&gt;

&lt;p&gt;To do this, let’s assume that our application will run in the ‘foobar’ namespace within the cluster.&lt;/p&gt;

&lt;p&gt;Create the namespace if it doesn’t already exist:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create namespace foobar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Download the WoTT CA certificate bundle:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl -s https://api.wott.io/v0.2/ca-bundle | \
  jq -r .ca_bundle &amp;gt; wott-ca.crt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Upload the CA certificate to the cluster:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl create secret generic wott-ca \
  -n foobar \
  --from-file=ca.crt=wott-ca.crt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can verify that we the secret was properly created by running:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get secrets -n foobar
NAME                  TYPE                                  DATA      AGE
[...]
wott-ca               Opaque                                1         4s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With CA in place, we can move on to configuring the &lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/ingress/&quot;&gt;Ingress object&lt;/a&gt;. The Ingress object is responsible for informing the Ingress Controller that it should route traffic addressed to a given hostname to a particular service.&lt;/p&gt;

&lt;p&gt;Here’s an example of the YAML file for such configuration (here we are using cert-manager for the SSL configuration):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    certmanager.k8s.io/acme-challenge-type: http01
    certmanager.k8s.io/issuer: letsencrypt-prod
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream: &quot;true&quot;
    nginx.ingress.kubernetes.io/auth-tls-secret: foobar/wott-ca
    nginx.ingress.kubernetes.io/auth-tls-verify-client: &quot;on&quot;
    nginx.ingress.kubernetes.io/auth-tls-verify-depth: &quot;2&quot;
  name: mtls-test
  namespace: api
spec:
  rules:
  - host: mtls-test.example.com
    http:
      paths:
      - backend:
          serviceName: foobar
          servicePort: 80
        path: /?(.*)
  tls:
  - hosts:
    - mtls-test.example.com
    secretName: le-secret-mtls-test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The secret for mTLS lies in the various ‘auth-tls’ annotations that we have above. These annotations tell Nginx to configure auth-tls (i.e. mTLS) for this endpoint.&lt;/p&gt;

&lt;p&gt;We can now leverage the HTTP headers that Nginx is passing on to the appserver(s) just like we did in our &lt;a href=&quot;https://wott.io/blog/tutorials/2019/07/15/mtls-with-nginx&quot;&gt;Nginx mTLS blog post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The two headers that you likely want to use are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP_SSL_CLIENT_VERIFY&lt;/li&gt;
  &lt;li&gt;HTTP_SSL_CLIENT_SUBJECT_DN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once you have this all configured, you can now communicate directly from your IoT devices to your Kubernetes cluster using mTLS and the WoTT certificate as your identity:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo curl \
  --key /opt/wott/certs/client.key \
  --cert /opt/wott/certs/client.crt \
  https://mtls-test.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hopefully this all made sense. If not, feel free to reach out to use on Twitter at &lt;a href=&quot;https://twitter.com/wottsecurity&quot;&gt;@WoTTSecurity&lt;/a&gt;.&lt;/p&gt;</content><author><name>Viktor Petersson</name></author><category term="tutorials" /><category term="Open Source" /><summary type="html">Bridging Edge IoT devices with Kubernetes</summary></entry><entry><title type="html">Using WoTT to Secure Access to a Mosquitto MQTT Server</title><link href="https://wott.io/blog/tutorials/2019/07/15/mosquitto-mqtt" rel="alternate" type="text/html" title="Using WoTT to Secure Access to a Mosquitto MQTT Server" /><published>2019-07-15T17:00:00+00:00</published><updated>2019-07-15T17:00:00+00:00</updated><id>https://wott.io/blog/tutorials/2019/07/15/mosquitto-mqtt</id><content type="html" xml:base="https://wott.io/blog/tutorials/2019/07/15/mosquitto-mqtt">&lt;h1 id=&quot;using-wott-to-cryptographically-secure-access-between-a-mosquitto-brokered-mqtt-client-and-server&quot;&gt;Using WoTT to Cryptographically Secure Access Between a Mosquitto Brokered MQTT Client and Server&lt;/h1&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Mosquitto is a lightweight message broker for MQTT. MQTT itself is a pub-sub messaging protocol that is particularly popular amongst IoT applications due to its optimisation for high-latency networks. Together, they are effective for IoT usage being low-power to run and adding a layer of security to IoT devices.&lt;/p&gt;

&lt;p&gt;By default, the connection between a Mosquitto run client and server is unencrypted. Mosquitto does have provisions for securing messages between client and server that are very easy to configure, although most of these options involve a password file. There is a second option you can use (and the one we will be using in this example) through an ACL file - or Access Control List. The ACL is essentially a list of permissions that are granted to particular users or processes. Keeping passwords in a system like this can be dangerous particularly when used without TLS as anyone with access to the network can potentially find the password. As you can imagine, this is a huge breach of security. We circumvent this by using WoTT’s unique device ID to secure the connection instead through the ACL file.&lt;/p&gt;

&lt;p&gt;Here we’ll look at using WoTT’s unique device ID to authenticate and secure access for a Mosquitto brokered MQTT protocol. Essentially we are identifying the devices cryptographically thus removing the need for usernames and passwords. This is done by assigning specific permissions to allowed users (or devices) according to their WoTT device ID which is recorded in the ACL file. In this example, we are securing messages to an MQTT temperature topic hosted by the Mosquitto server.&lt;/p&gt;

&lt;p&gt;You will need two WoTT devices with the &lt;a href=&quot;https://wott.io/documentation/getting-started&quot;&gt;WoTT Agent&lt;/a&gt; installed. We recommend that at least one of these is a Debian machine for the server (although two Pis is fine).&lt;/p&gt;

&lt;p&gt;For this example, you will need Docker CE and therefore a distribution of Raspbian or Debian. Installation instructions for Docker &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/debian/&quot;&gt;here&lt;/a&gt;.
Installation of Docker CE is a different on Rasbperry Pis. More information is in the Docker installation link above.&lt;/p&gt;

&lt;p&gt;We will also be asking you to clone our code snippets repository from Github, so ensure you have &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; on your system. Otherwise you can opt to use &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; to manually clone the required files (see previous code snippet examples on how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; for installation). For this tutorial, we will assume you have cloned our repo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; while not required, familiarity with Mosquitto config files may also be helpful. If not, don’t worry; but we encourage you to play around with our included files.&lt;/p&gt;

&lt;h2 id=&quot;getting-set-up&quot;&gt;Getting set up&lt;/h2&gt;

&lt;p&gt;Before we start, please clone our &lt;a href=&quot;https://github.com/WoTTsecurity/examples&quot;&gt;repository&lt;/a&gt; with WoTT’s example code snippets onto your devices:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/WoTTsecurity/examples.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you navigate inside this folder, you will find a few folders. For this example we are interested in ‘mosquitto-client’ and ‘mosquitto-server.’&lt;/p&gt;

&lt;p&gt;Alternatively, you can download the files needed using &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; followed by the raw output of the files if you prefer. In this case download the client files on the client device and server files on the server device.&lt;/p&gt;

&lt;p&gt;If you are using a Debian machine and a Rasberry Pi, we reccommend setting up your server on the Debian machine with the Pi acting as the client as this will be the most common form of setup.&lt;/p&gt;

&lt;p&gt;We will now break down the tutorial into client and server.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-the-server&quot;&gt;Setting up the server&lt;/h2&gt;

&lt;p&gt;First, we need to set up and establish our server with Mosquitto. For this we will need a Mosquitto configuration file. Information regarding set up of the &lt;a href=&quot;https://mosquitto.org/man/mosquitto-conf-5.html&quot;&gt;configuaration files&lt;/a&gt; is readily available if you wish to peruse through this yourself. Assuming you have the repository cloned, navigate to the directory on your server device (if you have a Debian machine and a Pi, the Debian machine):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd examples
$ cd mosquitto-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;running &lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt; you will notice there are 3 files including a &lt;code class=&quot;highlighter-rouge&quot;&gt;mosquitto.conf&lt;/code&gt; file. This contains the information we need to set up our Mosquitto server. By default we have the &lt;code class=&quot;highlighter-rouge&quot;&gt;acl_file&lt;/code&gt; enabled. This is to secure access to the server later, however if you want to test this without the ACL configured, just find and comment out this line in the config:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;acl_file /mosquitto/config/permission.acl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This means that &lt;em&gt;all&lt;/em&gt; messages to the server are now accepted. This may be useful to you for testing when establishing connection between your devices although we reccommend keeping the file as is.&lt;/p&gt;

&lt;p&gt;In this example, we provide the ACL file for you to configure with WoTT Device details to secure this. This file is in the same directory as &lt;code class=&quot;highlighter-rouge&quot;&gt;permissions.acl.&lt;/code&gt;
Open this in your favourite text editor. You will notice it is filled with comments. Each block refers to a type of permissions you can associate with a device followed by the topic that you are giving permissions for. For this example, our messaging topic is &lt;code class=&quot;highlighter-rouge&quot;&gt;wott/temperature&lt;/code&gt; and can receive messages of temperature.&lt;/p&gt;

&lt;p&gt;Replace the relevant fields with the details of your specific WoTT device. If you do not know the Device ID of your devices, simply run the following command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo wott-agent whoami
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This will print the unique ID of your device. Remember to use the correct subscribing/publishing device for your purposes. For this example, feel free to use the first block to give read and write permissions to your publishing device (the device &lt;em&gt;sending&lt;/em&gt; messages); or assign it write only permissions (this is technically the most secure option). Give permissions to the subscribing device as well. With the ACL set up, you can now start up your server with the third file in the directory, a simple bash script &lt;code class=&quot;highlighter-rouge&quot;&gt;run.sh&lt;/code&gt;. In the same directory:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./run.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You should get an output similar to this :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1563214210: mosquitto version 1.6.3 starting
1563214210: Config loaded from /mosquitto/config/mosquitto.conf.
1563214210: Opening ipv4 listen socket on port 8883.
1563214210: Opening ipv6 listen socket on port 8883.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; you may need to prefix with &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; if your permissions are denied. If it still does not work, ensure the file is executable.&lt;/p&gt;

&lt;p&gt;The server is now up and running. We can now move onto the client.&lt;/p&gt;

&lt;h2 id=&quot;connecting-the-client&quot;&gt;Connecting the client&lt;/h2&gt;

&lt;p&gt;On your client device, assuming you have our examples repository downloaded, navigate to the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd examples
$ cd mosquitto-client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;There are 3 files of note in this directory, &lt;code class=&quot;highlighter-rouge&quot;&gt;pub.sh&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;sub.sh&lt;/code&gt;, and, &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;. You do not need to alter any of these files for this example. There is an additional &lt;code class=&quot;highlighter-rouge&quot;&gt;README.md&lt;/code&gt; file containing client set up instructions although these are also contained in this document. If you choose to use these files in the future, you can refer to the &lt;code class=&quot;highlighter-rouge&quot;&gt;README&lt;/code&gt; instead of this tutorial for quick reference.&lt;/p&gt;

&lt;p&gt;We will familiarise you with the files in the meantime.&lt;/p&gt;

&lt;h3 id=&quot;subscribing&quot;&gt;Subscribing&lt;/h3&gt;

&lt;p&gt;First, we need to set up the Docker container with the Dockerfile. The file contains installation instructions for the Mosquitto client so you do not have to install it manually. Ensure you are in the correct directory &lt;code class=&quot;highlighter-rouge&quot;&gt;mosquitto-client&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker build . -t wott-mqtt-client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The key thing this has done is created the topic &lt;code class=&quot;highlighter-rouge&quot;&gt;wott/temperature&lt;/code&gt; which we will be publishing/subscribing to.&lt;/p&gt;

&lt;p&gt;Now, to set up the subscriber in the same terminal instance:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export MQTT_SERVER_WOTT_ID=ServerDeviceID.d.wott.local
$ export MQTT_SERVER_IP=Server_inet_IP
$ sudo docker run -ti --rm \
    -e MQTT_SERVER=$MQTT_SERVER_WOTT_ID \
    --add-host $MQTT_SERVER_WOTT_ID:$MQTT_SERVER_IP \
    -v /opt/wott/certs:/opt/wott/certs:ro \
    wott-mqtt-client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you do not know your IP address, you can obtain this through &lt;code class=&quot;highlighter-rouge&quot;&gt;ip addr show&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo ifconfig&lt;/code&gt; and the value corresponds to the &lt;code class=&quot;highlighter-rouge&quot;&gt;inet&lt;/code&gt; value. Alternatively, you can get the value for the specific port you are using (in this case port 8883) through &lt;code class=&quot;highlighter-rouge&quot;&gt;ip route get 8.8.8.3&lt;/code&gt;. Make sure you do this on your &lt;em&gt;server&lt;/em&gt; device.&lt;/p&gt;

&lt;p&gt;The subscriber should now be running. As there are no messages being published, you will not see anything on the terminal yet. To end the process use &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL + C&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;publishing&quot;&gt;Publishing&lt;/h3&gt;

&lt;p&gt;With the subscriber running, in a new instance of terminal; run the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export MQTT_SERVER_WOTT_ID=ServerDeviceID.d.wott.local
$ export MQTT_SERVER_IP=Server_inet_IP
$ sudo docker run -ti --rm \
    -e MQTT_SERVER=$MQTT_SERVER_WOTT_ID \
    --add-host $MQTT_SERVER_WOTT_ID:$MQTT_SERVER_IP \
    -v /opt/wott/certs:/opt/wott/certs:ro \
    wott-mqtt-client /pub.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You will get an output that looks something like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sending temperature 40
Sending temperature 18
Sending temperature 42
Sending temperature 33
Sending temperature 3
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This instance is publishing temperature data to the &lt;code class=&quot;highlighter-rouge&quot;&gt;wott/temperature&lt;/code&gt; topic. To confirm this, check the subscriber terminal window now. If the ACL has been configured correctly, you will see the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wott/temperature 40
wott/temperature 18
wott/temperature 42
wott/temperature 33
wott/temperature 3
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can also check the terminal running the server on the server device to see the connections from the client.
And that’s it. You have successfully set up a Mosquitto brokered MQTT server and client.&lt;/p&gt;

&lt;p&gt;To stop the publisher, you will need to stop the Docker container itself, &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL + C&lt;/code&gt; will not work. To do so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker container ps

CONTAINER ID        IMAGE               COMMAND                  [...]
8bfe61edb3bd        wott-mqtt-client    &quot;/pub.sh&quot;                [...]

[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You’re looking for the Docker container that has the same &lt;code class=&quot;highlighter-rouge&quot;&gt;IMAGE&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;COMMAND&lt;/code&gt; details as the above as it corresponds to the process containing the publisher. There may also be other containers running such as the subscriber.&lt;/p&gt;

&lt;p&gt;Copy the Container ID of the publisher and run:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo docker stop Container_ID_of_publisher
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This should stop the process. To confirm, just check the terminal with the publisher and it will no longer be publishing data. It may take up to a few seconds.&lt;/p&gt;

&lt;h2 id=&quot;finishing-notes&quot;&gt;Finishing Notes&lt;/h2&gt;

&lt;p&gt;Mosquitto is a very convenient way of managing MQTT messages with inbuilt features that promote security. Hopefully we’ve shown how easy it is to use WoTT to secure a Mosquitto server and client based off our unique ID that we assign to each WoTT device. Ultimately security through identity is the way forward as passwords can still be all too easily intercepted- especially on non TLS connections. ACL files are one of many ways we can use identity over passwords.&lt;/p&gt;

&lt;p&gt;Of course, our example code snippets are just that: an example; so feel free to experiment and augment the code as you see fit. We encourage you to go through our examples and change configurations and files for your needs. There’s much more to Mosquitto than we have included in this example, so check out the &lt;a href=&quot;https://mosquitto.org&quot;&gt;Mosquitto website&lt;/a&gt; for more information.&lt;/p&gt;</content><author><name>Fiona McAllister</name></author><category term="tutorials" /><category term="Open Source" /><summary type="html">Using WoTT to Cryptographically Secure Access Between a Mosquitto Brokered MQTT Client and Server</summary></entry><entry><title type="html">Configuring Nginx with client certificate authentication (mTLS)</title><link href="https://wott.io/blog/tutorials/2019/07/15/mtls-with-nginx" rel="alternate" type="text/html" title="Configuring Nginx with client certificate authentication (mTLS)" /><published>2019-07-15T08:00:00+00:00</published><updated>2019-07-15T08:00:00+00:00</updated><id>https://wott.io/blog/tutorials/2019/07/15/mtls-with-nginx</id><content type="html" xml:base="https://wott.io/blog/tutorials/2019/07/15/mtls-with-nginx">&lt;h1 id=&quot;configuring-nginx-with-client-certificate-authentication-mtls&quot;&gt;Configuring Nginx with client certificate authentication (mTLS)&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Required Skill Level&lt;/strong&gt;: Medium to Expert&lt;/p&gt;

&lt;p&gt;One of the cornerstones of Zero Trust Networking is Mutual TLS (known as mTLS). In simple terms, this means that each client is required to present a certificate to talk to the server. This is different compared to how your client (e.g. your web browser) only verifies the identity of the server. The client itself does not need to present any identity. The identity piece is normally solved using some kind of credential (such as a username/password or API token).&lt;/p&gt;

&lt;p&gt;By replacing credentials with certificates, we are able to significantly improve the security (in particular with short-lived certificates, like the ones we offer), while also making the implementation &lt;em&gt;easier&lt;/em&gt; (as it removes the need for API key/credential management).&lt;/p&gt;

&lt;p&gt;In this article we will make this all more concrete by creating a sample implementation. The sample implementation will consist of a simple Python appserver, with an Nginx reverse proxy in front of it. Nginx will reject all connections without a valid certificate, and the appserver will then compare the certificate to a whitelist of devices that are allowed to talk to the server.&lt;/p&gt;

&lt;p&gt;Depending on your implementation, you could either use two Raspberry Pis for this, or you could use a Debian virtual machine as the server, and a Raspberry Pi as the client. The latter would be a more realistic setup for a live installation. Moreover, in the latter example, you can for instance use &lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt&lt;/a&gt; as the public SSL certificate. This is useful if you use the same Nginx server to serve content for other clients, and not just for mTLS.&lt;/p&gt;

&lt;h2 id=&quot;preparation&quot;&gt;Preparation&lt;/h2&gt;

&lt;p&gt;Before we begin, we first need to install the WoTT agent on both the server and client(s). You can find instruction on how to do this &lt;a href=&quot;https://wott.io/documentation/getting-started&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once you have the WoTT agent installed, we need to install both &lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/debian/&quot;&gt;Docker CE&lt;/a&gt; and Docker Compose (you can install Docker Compose on a Raspberry Pi by just running &lt;code class=&quot;highlighter-rouge&quot;&gt;apt update &amp;amp;&amp;amp; apt install docker-compose&lt;/code&gt;). We use these to simplify the installation, as we are able to better pin the requirements.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-the-server&quot;&gt;Setting up the server&lt;/h2&gt;

&lt;p&gt;Let’s start by setting up the server. To save you the time (and potential typos), we have create a sample repo for this, so all you need to do is to clone the repository:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/WoTTsecurity/examples.git
$ cd examples/nginx-with-mtls-and-appserver
$ docker-compose build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Thanks to Docker and Docker Compose, this is all we need to kick off the demo. The only final thing we need to do is to add the device that we will be connecting &lt;em&gt;from&lt;/em&gt; to the whitelist. You can find out the WoTT Device ID by running &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo wott-agent whoami&lt;/code&gt; on the device you’re connecting from.&lt;/p&gt;

&lt;p&gt;With the Device ID at hand, simply run the following commands on the server:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo &quot;MyDeviceId.d.wott.local&quot; &amp;gt;&amp;gt; appserver/whitelist.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can now fire up the server by simply running:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ docker-compose up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To test the connection from your client, we need to find out two things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The IP of the server&lt;/li&gt;
  &lt;li&gt;The WoTT Device ID of the server&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lets-test-the-client&quot;&gt;Let’s test the client&lt;/h2&gt;

&lt;p&gt;Armed with the above information, we can now turn to our trusty old friend &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First, let’s try connecting without passing on our certificate:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo curl \
  --cacert /opt/wott/certs/ca.crt \
  --resolve 'MyServerID.d.wott.local:443:a.b.c.d' \
  https://MyServerId.d.wott.local

  &lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&lt;/span&gt;400 No required SSL certificate was sent&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;&lt;/span&gt;400 Bad Request&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;center&amp;gt;&lt;/span&gt;No required SSL certificate was sent&lt;span class=&quot;nt&quot;&gt;&amp;lt;/center&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;&lt;/span&gt;nginx/1.16.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/center&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Because we have configured Nginx to require an SSL certificate, the server will reject the connection, and you won’t even be able to reach the appserver that we reverse proxy to.&lt;/p&gt;

&lt;p&gt;If we however pass on our certificate (and key), we are able to successfully access the appserver:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo curl \
  --key /opt/wott/certs/client.key \
  --cert /opt/wott/certs/client.crt \
  --cacert /opt/wott/certs/ca.crt \
  --resolve 'MyServerID.d.wott.local:443:a.b.c.d' \
  https://MyServerId.d.wott.local

Access Granted!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;thats-really-cool-but-what-happened-here&quot;&gt;That’s really cool, but what happened here?&lt;/h2&gt;

&lt;p&gt;There’s a lot to unpack in what we did above, so let’s start with the client and work our way forward.&lt;/p&gt;

&lt;h3 id=&quot;client&quot;&gt;Client&lt;/h3&gt;

&lt;p&gt;Let’s break down the &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; command we used to successfully connect to the server.&lt;/p&gt;

&lt;p&gt;These two lines tell &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; to send the client certificate and key.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  --key /opt/wott/certs/client.key
  --cert /opt/wott/certs/client.crt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is our cryptographic identity provided by WoTT. In short, this replaces the need for a username and pasword. It should however be said that the key is not sent to the server (unlike a password), but rather it is used for a cryptographic challenge (vastly simplified).&lt;/p&gt;

&lt;p&gt;Next, we need to tell &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; to use the WoTT CA certificate to verify the remote server against (since WoTT is not a public CA):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  --cacert /opt/wott/certs/ca.crt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Lastly, we use a neat little feature in &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; to tell it to map ‘MyServerID.d.wott.local’ to an IP address. We could instead have added this to our &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; file, but this is a quicker workaround when testing.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  --resolve 'MyServerID.d.wott.local:443:192.168.X.Y'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;nginx&quot;&gt;Nginx&lt;/h3&gt;

&lt;p&gt;Let’s move on to Nginx. We use Nginx as a reverse proxy for the appserver that we will cover below. We do this for a few reasons. The first reason is simply because Nginx is battle tested and does the first level of screening. If for instance, the client fails to present a valid certificate, the request will not be forwarded to the appserver. Hence this is a nice safety net from possible bugs in the appserver code.&lt;/p&gt;

&lt;p&gt;In this particular example, we also terminate the TLS connection in Nginx. Should we want to improve security further (and adopt proper Zero Trust Networking), we could encrypt the traffic Nginx and the appserver too (even if they are on the same host in this case).&lt;/p&gt;

&lt;p&gt;If the certificate is valid, Nginx will then reverse proxy the connection to the appserver.&lt;/p&gt;

&lt;p&gt;The Nginx configuration is fairly straight forward and can be found &lt;a href=&quot;https://github.com/WoTTsecurity/examples/blob/master/nginx-with-mtls-and-appserver/nginx/reverse-proxy.conf&quot;&gt;here&lt;/a&gt;. The most noteworthy lines in the configuration are these:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This will return a 403 to all clients without a proper certificate
if ($ssl_client_verify != &quot;SUCCESS&quot;) { return 403; }

# This tells Nginx what CA to verify against
ssl_client_certificate /opt/wott/certs/ca.crt;

# This tells Nginx to verify clients
ssl_verify_client on;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In theory, we could extend this further and write a &lt;a href=&quot;https://github.com/openresty/lua-nginx-module#readme&quot;&gt;LUA script&lt;/a&gt; to do further validation, and even incorporate the whitelisting that we will get to in the appserver section, but that’s something for another day.&lt;/p&gt;

&lt;h3 id=&quot;appserver&quot;&gt;Appserver&lt;/h3&gt;

&lt;p&gt;Assuming the client passed all validations, the request will be passed on to the appsever. The &lt;a href=&quot;https://github.com/WoTTsecurity/examples/blob/master/nginx-with-mtls-and-appserver/appserver/app.py&quot;&gt;appserver&lt;/a&gt; is a simple Flask app. In essence, all it does is to provide some validations on the headers. Since Nginx will pass on various HTTP Headers to the appserver, we can use them to implement access control.&lt;/p&gt;

&lt;p&gt;When a request hits the appserver, it will check the HTTP header &lt;code class=&quot;highlighter-rouge&quot;&gt;Ssl-Client-Verify&lt;/code&gt; is set to ‘SUCCESS’. If it isn’t, the request will be rejected with an error message. In theory, this shouldn’t be possible, since Nginx should never forward such request, but when it comes to security it’s better to be safe than sorry.&lt;/p&gt;

&lt;p&gt;Assuming the above condition is correct, the appserver will parse the Client ID (from the ‘Ssl-Client’ header) and compare it to a whitelist (&lt;code class=&quot;highlighter-rouge&quot;&gt;whitelist.txt&lt;/code&gt; from above). The whitelist is a simple text file with one Device ID per line. Only if the Client ID (i.e. the WoTT Device ID) matches a record in the whitelist, the appserver will return “Access Granted!”.&lt;/p&gt;

&lt;p&gt;While the appserver is far from ready for production usage, it should help illustrate the setup such that it could be adopted into most languages and frameworks.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Hopefully you found this tutorial useful and that it helped bring the concept of Zero Trust Networking and mTLS to life with a real-world example of how it can be implemented with a relatively small amount of code.&lt;/p&gt;

&lt;p&gt;If you have any questions, please get in touch with us on &lt;a href=&quot;https://twitter.com/wottsecurity&quot;&gt;Twitter&lt;/a&gt; or open a Github Issue if you found any issues.&lt;/p&gt;</content><author><name>Viktor Petersson</name></author><category term="tutorials" /><category term="Open Source" /><summary type="html">Configuring Nginx with client certificate authentication (mTLS)</summary></entry><entry><title type="html">Using WoTT credentials to manage access to Adafruit IO feeds</title><link href="https://wott.io/blog/tutorials/2019/06/27/adafruit-io" rel="alternate" type="text/html" title="Using WoTT credentials to manage access to Adafruit IO feeds" /><published>2019-06-27T17:00:00+00:00</published><updated>2019-06-27T17:00:00+00:00</updated><id>https://wott.io/blog/tutorials/2019/06/27/adafruit-io</id><content type="html" xml:base="https://wott.io/blog/tutorials/2019/06/27/adafruit-io">&lt;h1 id=&quot;using-adafruit-io-with-wott-credentials&quot;&gt;Using Adafruit IO with WoTT Credentials&lt;/h1&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://io.adafruit.com&quot;&gt;Adafruit IO&lt;/a&gt; is a free cloud service interested in making IoT accessible to everyone through presenting data in a useful and user-friendly way. Services that they provide include linking your IoT devices to Twitter and weather services. You can also use Adafruit IO to monitor and control temperature sensitive devices; or to change the colours of an RGB lightbulb through their user-friendly dashboard. These are just a few examples of how you can utilise Adafruit’s IO.&lt;/p&gt;

&lt;p&gt;We’re interested in Adafruit IO as it provides a means for us to communicate with our IoT devices via messages through either an MQTT or HTTP service. WWe can therefore interact with Adafruit’s services and use our WoTT provided credentials to secure it.&lt;/p&gt;

&lt;p&gt;For this example you will need a device with the WoTT agent installed and a browser. You will also need an Adafruit IO account as well as a WoTT dash account. We will show you to set these up later in the guide if you haven’t done so already.&lt;/p&gt;

&lt;p&gt;This example contains code snippets. To access these, clone our &lt;a href=&quot;https://github.com/WoTTsecurity/examples&quot;&gt;examples&lt;/a&gt; repository by doing the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/WoTTsecurity/examples.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Alternatively, you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt; and download the relevant files. Instructions included for both.&lt;/p&gt;

&lt;h2 id=&quot;installing-and-setting-up-to-use-adafruit-io&quot;&gt;Installing and setting up to use Adafruit IO&lt;/h2&gt;

&lt;p&gt;The first thing you will need to do, is to &lt;a href=&quot;https://accounts.adafruit.com/users/sign_up&quot;&gt;sign up&lt;/a&gt; for Adafruit IO so you can access their &lt;a href=&quot;https://io.adafruit.com/&quot;&gt;dashboard&lt;/a&gt;. Familiarise yourself with their &lt;a href=&quot;https://learn.adafruit.com/series/adafruit-io-basics&quot;&gt;basic guides&lt;/a&gt;. For this example, we will be creating a ‘Feed.’ First however, you will need to have the Adafruit IO client downloaded on your system. We will be using their Python client.&lt;/p&gt;

&lt;p&gt;To install:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ apt update &amp;amp;&amp;amp; apt install -y python3 python3-pip curl
$ pip3 install adafruit-io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now we’re all set up, we can create a feed to later call via MQTT.&lt;/p&gt;

&lt;h2 id=&quot;creating-a-feed-for-mqtt-messaging&quot;&gt;Creating a Feed for MQTT messaging&lt;/h2&gt;

&lt;p&gt;Login to the Adafruit IO dashboard. Navigate to the ‘Feeds’ page on the left-hand side menu. Hover over actions and select ‘Create a New Feed.’ The feed acts as a channel or datastream through which your device connects to Adafruit IO. We are going to create a feed that is called via MQTT. In other words, the feed becomes the topic from which messages are published/subscribed to.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;create feed&quot; src=&quot;https://wott.io/assets/blog/adafruit-add-21106ff597b5fe9bca13995f8e116602c02e5371f9d81dc073ab764ee70a132b.png&quot; integrity=&quot;sha256-IRBv9Ze1/pvKE5lfjhFmAsAuU3H52B3Ac6t2TucKEys=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/25fd86-c2a28625deb059d4b48d00de00b9552ad08f4c3bb886042ed84a6acbe75e0989.png 2x, https://wott.io/assets/cd12eb-38b8d30fff0055c016fd74c0be16877aa67891310a2aadc8794264197ed71916.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The feed name refers to the type of data you are observing- for example temperature or humidity. To keep things simple, we are just going to observe data and name the feed ‘data feed.’ The description is supposed to provide some more in-depth information about the feed. When using sensor data, this is going to be something like temperature or humidity, however for this exmaple we are just dealing with very basic pub/sub messages, so our data type is generic.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;name feed&quot; src=&quot;https://wott.io/assets/blog/feed-details-ea085f388451196a3884b7a0524e4c940bbf75874e5bdcee2de1327703adccc7.png&quot; integrity=&quot;sha256-6ghfOIRRGWo4hLegUk5MlAu/dYdOW9zuLeEydwOtzMc=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/de0189-139d10f5080953014b1ebed448051b18eb3ec5c8bfa268261ddf748b7521f171.png 2x, https://wott.io/assets/60856b-203eaa76b14bde949181ade9764c00da7d089504c65105671ef8dc25aa9d7e58.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; it is possible to create the feeds using a simple python application. If you prefer a more codified style of set up, you can follow &lt;a href=&quot;https://adafruit-io-python-client.readthedocs.io/en/latest/feeds.html&quot;&gt;this&lt;/a&gt; guide.&lt;/p&gt;

&lt;h2 id=&quot;creating-credentials-in-wott-dash&quot;&gt;Creating credentials in WoTT dash&lt;/h2&gt;

&lt;p&gt;In order to call the Adafruit API via HTTP access, it requires a key. You can find this key on the left-hand side of your Adafruit dasboard as you did with ‘Feeds’ under &lt;code class=&quot;highlighter-rouge&quot;&gt;AIO key&lt;/code&gt;. You will be brought to a page akin to this:&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;AIO key&quot; src=&quot;https://wott.io/assets/blog/aio-key-modal-f866f82bdffa097d3781bfcf79bf1f305b9d7854d84fcbd0c9321d6d29f0ef65.png&quot; integrity=&quot;sha256-+Gb4K9/6CX03gb/Peb8fMFudeFTYT8vQyTIdbSnw72U=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/9d26f5-881ef4c1f95fc774d36eb645716042476464c512667dc380bd6b3ea77fa3f182.png 2x, https://wott.io/assets/953c52-05a085b60300499f08bcf817e62fe962b62f85a92c98eb29034e2b851ec91384.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;These are your unique Adafruit details. We can add these to WoTT’s dashboard as a new credential where the value is your personal username followed by the &lt;code class=&quot;highlighter-rouge&quot;&gt;Active Key&lt;/code&gt; value. To do so, you will need to login or create an account for the &lt;a href=&quot;https://dash.wott.io&quot;&gt;WoTT dash&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;WoTT login&quot; src=&quot;https://wott.io/assets/blog/wott-dash-212c3643e41361a1a771dc7435ae6b12c4f1afde0f8b56a437175997adf118e2.png&quot; integrity=&quot;sha256-ISw2Q+QTYaGncdx0Na5rEsTxr94Pi1akNxdZl63xGOI=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/03bed4-49b51798b8601d330871ba8b44d073ee97cbbb19f910727cbbdf45119134b4e2.png 2x, https://wott.io/assets/deedd0-476ee37715e1a86c4ae07074eb8961757361084f009ef8ad34fb0f0924d144b3.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you already have the WoTT dash and have registered your devices, you can skip ahead to inputting the credentials of the device. Otherwise, register your WoTT agent device to the dash by obtaining the Device ID and Claim Token by doing the following commands on said device:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo wott-agent whoami
$ sudo wott-aget claim-token
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and pasting the output into the ‘Claim Device’ segment of the WoTT dash. This device is now claimed and registered to the WoTT dash. You can view the list of your claimed devices on the main dashboard. Navigate to your newly registered device and add a new tag, &lt;code class=&quot;highlighter-rouge&quot;&gt;adafruit&lt;/code&gt; to it. Through these tags, WoTT identifies which devices specific credentials are intended for.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Adafruit tags&quot; src=&quot;https://wott.io/assets/blog/adafruit-tags-4c74ebb36ad6e163a778f7a8db3049666a631c012c7736a7bdeed264a3ce850b.png&quot; integrity=&quot;sha256-THTrs2rW4WOnePeo2zBJZmpjHAEsdzanve7SZKPOhQs=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/378d39-77584205fa3f1736361aa890e84a7321133941777f82224a448ac97dfe406187.png 2x, https://wott.io/assets/7d7aaa-0b7298efffed28beeb72c54b690218077a06d74aea767f21ab86fe3d76f18663.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now that we are all set up, we need to create the credentials with the Adafruit information. Navigate to the ‘Credentials’ page of the WoTT dash and a new credential. Input the following into the fields:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Name = adafruit_aio
Key = credentials
Value = username:key
Tags = adafruit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;using your relevant information from the Adafruit AIO key.
Note the &lt;code class=&quot;highlighter-rouge&quot;&gt;adafruit&lt;/code&gt; tag here. Ensure that the device you will be downloading the credentials on has a matching tag.&lt;/p&gt;

&lt;p&gt;To download the credential, restart the WoTT Agent by running:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo service wott-agent restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;There will now be a JSON file on your system containing your credentials.&lt;/p&gt;

&lt;h2 id=&quot;setting-up-adafruit-feed-sharing-with-an-mqtt-client&quot;&gt;Setting up Adafruit feed sharing with an MQTT Client&lt;/h2&gt;

&lt;p&gt;We have included a modified example of the Adafruit feed sharing tutorial in this guide which utilises WoTT’s credentials rather than hard coding your details into the application. To run the example using &lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir ~/wott-adafruit-mqtt-example
$ cd ~/wott-adafruit-mqtt-example
$ curl -o mqtt_shared_feeds.py https://raw.githubusercontent.com/WoTTsecurity/examples/master/adafruit-io/mqtt_shared_feeds.py
$ sudo python3 mqtt_shared_feeds.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you have our repository cloned instead, navigate to the examples directory and do the following instead:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd adafruit-io
$ sudo python3 mqtt_shared_feeds.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you are successful, you should receive a message like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Publishing a new message every 10 seconds (press Ctrl-C to quit)...
Publishing 96 to data feed
Connected to Adafruit IO!
Publishing 12 to data feed
Feed data feed received new value: 12
Publishing 52 to data feed
Feed data feed received new value: 52
[...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;On your Adafruit IO dash, you should see the data being received on your feed:&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;feed data&quot; src=&quot;https://wott.io/assets/blog/adafruit-feed-88cdb8ceb9f8c0820123a6ad3b8bad5e382b73d05d35034e0ca678a2f273033e.png&quot; integrity=&quot;sha256-iM24zrn4wIIBI6atO4utXjgrc9BdNQNODKZ4ovJzAz4=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/13d874-adee9987226294aa7f6e890e456aa4015ed683748247e48cb6d3334db17e78dc.png 2x, https://wott.io/assets/861588-2e16c2f57b3fe12d84449b2e8b205217db9e754cc222740fe9d647f3524c944c.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; your values will be different to this example as they are randomly generated, use the above as a reference point only.&lt;/p&gt;

&lt;h2 id=&quot;common-errors&quot;&gt;Common errors&lt;/h2&gt;

&lt;p&gt;Adafruit IO Python uses Python 3. If you have both a version of Python 2 and Python 3 on your machine, you will need to use the appropriate commands (for example pip vs pip3).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;No module named Adafruit_IO&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;File &quot;/Users/user/dir/app_dir/mqtt_shared_feeds.py&quot;, line 10, in &amp;lt;module&amp;gt;
    from Adafruit_IO import  MQTTClient
ImportError: No module named Adafruit_IO
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This happens when Adafruit IO is not installed correctly. The reccommended fix is to &lt;a href=&quot;https://github.com/adafruit/Adafruit_IO_Python&quot;&gt;manually install&lt;/a&gt; Adafruit IO into the directory that you are working in (&lt;code class=&quot;highlighter-rouge&quot;&gt;wott-adafruit-mqtt-example&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&quot;closing-notes&quot;&gt;Closing notes&lt;/h2&gt;

&lt;p&gt;We have successfully used WoTT credentials to secure access to your Adafruit IO feed through an MQTT client!&lt;/p&gt;

&lt;p&gt;The Python application contained in this example is a modified version of Adafruit IO’s own MQTT feed sharing example. Feel free to edit, play with, and modify the app as you choose. Note that if you make changes to feed names, feed owners, etc; you will have to change this within the app (or within WoTT credentials to be more secure).&lt;/p&gt;

&lt;p&gt;Ensure that if you do add additional credentials to WoTT dashboard that you restart the WoTT agent to download the credentials immediately- otherwise WoTT will fetch the information every 15 minutes.&lt;/p&gt;</content><author><name>Fiona McAllister</name></author><category term="tutorials" /><category term="Open Source" /><summary type="html">Using Adafruit IO with WoTT Credentials</summary></entry><entry><title type="html">Using WoTT credentials to manage access to Screenly OSE</title><link href="https://wott.io/blog/tutorials/2019/06/25/screenly-ose" rel="alternate" type="text/html" title="Using WoTT credentials to manage access to Screenly OSE" /><published>2019-06-25T17:00:00+00:00</published><updated>2019-06-25T17:00:00+00:00</updated><id>https://wott.io/blog/tutorials/2019/06/25/screenly-ose</id><content type="html" xml:base="https://wott.io/blog/tutorials/2019/06/25/screenly-ose">&lt;h1 id=&quot;using-wott-to-secure-access-to-screenly&quot;&gt;Using WoTT to secure access to Screenly&lt;/h1&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Screenly is a service that provides digital signage and acts as an OS on the host device. Essentially it treats your host device as a streaming service that projects visual media (such as images and webpages) onto a monitor from multiple different sources. Think of it as a manager for your visual media- you send the content via a browser on the Screenly management page, and the host device projects that content onto a monitor.&lt;/p&gt;

&lt;p&gt;Screenly by default allows anyone within the network with the management page IP address to access it and send content. However, it does also provide HTTP authentication- and we can use WoTT’s credentials to secure our Screenly device so that we can restrict and verify those who have access to it.&lt;/p&gt;

&lt;p&gt;Screenly offers a free OSE version that you can use. For this example you will need a Raspberry Pi, a monitor for Screenly to project onto; and at least one browser device. You will also need to have an account for the &lt;a href=&quot;https://dash.wott.io&quot;&gt;WoTT Dashboard&lt;/a&gt; in order to manage WoTT credentials.&lt;/p&gt;

&lt;h2 id=&quot;installing-wott-agent-on-screenly-ose&quot;&gt;Installing WoTT agent on Screenly OSE&lt;/h2&gt;

&lt;p&gt;First you will need a Screenly OSE (the free version) device if you do not already.
Follow the instructions to install Screenly OSE on your Raspberry Pi &lt;a href=&quot;https://www.screenly.io/ose/&quot;&gt;here&lt;/a&gt;. We reccommend you follow the first option and use something like Etcher to flash the SD card with the Screenly OSE disk image. 
&lt;strong&gt;Note:&lt;/strong&gt; Screenly OSE will overwrite your OS.&lt;/p&gt;

&lt;p&gt;When the Raspberry Pi reboots, it will take you to the Screenly OSE network configuration. You will need to access the SSID as you would a wifi network and enter the password shown.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Screenly&quot; src=&quot;https://wott.io/assets/blog/screenly-setup-520903a934667ee4f2dfedbe9568ea6c39d43f746b7b3348cde4ba924e11044f.jpg&quot; integrity=&quot;sha256-UgkDqTRmfuTy3+2+lWjqbDnUP3RrezNIzeS6kk4RBE8=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/1629a1-fa3f27f61fb7671c9866eb3cb85bc2ae27884052fe23a7f56e968916ab44f2ff.jpg 2x, https://wott.io/assets/c8eb7f-c1f3af339c3ab5b9027e6d4a043ffb6f1a022fc8e049a8496547beb17c2a7c4c.jpg 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Then navigate to the Address shown and login with your network details. This will grant you access to the Screenly management page.&lt;/p&gt;

&lt;p&gt;Now we need to secure access to your Screenly OSE device. If you haven’t installed the WoTT Agent already, you can install it via the Screenly OSE installer. Just run:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./screenly/bin/run-upgrade.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;and select the WoTT agent from the installation options.&lt;/p&gt;

&lt;p&gt;To do this on the Screenly OSE device, you need to access the terminal through &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;ALT&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;F1&lt;/code&gt;. To return back to the GUI, it is &lt;code class=&quot;highlighter-rouge&quot;&gt;CTRL&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;ALT&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;F2&lt;/code&gt;. 
Once here, follow the WoTT agent installation as you would on any other device.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Optional:&lt;/strong&gt; If you want to avoid using the terminal directly on your Screenly OSE device in the future, enable SSH through the &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo raspi-config&lt;/code&gt; command. It is also reccommended that you change your Password from the default &lt;code class=&quot;highlighter-rouge&quot;&gt;raspberry&lt;/code&gt; (this will also improve your WoTT security score!) if you are going to do this.&lt;/p&gt;

&lt;p&gt;You will now need to register the Pi on the WoTT dashboard.&lt;/p&gt;

&lt;h2 id=&quot;downloading-wott-credentials-on-screenly-ose&quot;&gt;Downloading WoTT credentials on Screenly OSE&lt;/h2&gt;

&lt;p&gt;Login to the WoTT Dash and navigate to ‘Claim Device.’ If you have installed the WoTT agent recently, the relevant information should be displayed on your terminal screen. If not, use the following commands:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo wott-agent whoami
$ sudo wott-aget claim-token
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will give you your Device ID and the token value to claim your device.&lt;/p&gt;

&lt;p&gt;Your Raspberry Pi should now be registered. Navigate to your Dashboard and select the Pi:&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Pi&quot; src=&quot;https://wott.io/assets/blog/rasbpi-a8999635cf9b0dc73388bffed4197bb2b0d92fb778198160c6f6e01d674e02dc.png&quot; integrity=&quot;sha256-qJmWNc+bDccziL/+1Bl7srDZL7d4GYFgxvbgHWdOAtw=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/e711ef-06bff97ce1aad5af34ef4f51e2bc5457a5703a3325eb7e968e2b953e5b60c278.png 2x, https://wott.io/assets/d66040-1127908ad45b8616a193234770134b3174a40212b2423a6d1b30acc9c2d6a1c3.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;On the overview page, add a tag. This will be important for the credentials. This tag can be whatever you want, however we suggest something like &lt;code class=&quot;highlighter-rouge&quot;&gt;screenly-pi&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;pi&lt;/code&gt; or a variant of that form:&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;tag&quot; src=&quot;https://wott.io/assets/blog/tag-0174bc7f6a95922cc4554c994d2bf6f313661bd5d9ee7913a4a36ce883db0a10.png&quot; integrity=&quot;sha256-AXS8f2qVkizEVUyZTSv28xNmG9XZ7nkTpKNs6IPbChA=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/c5a555-31d887c3030c7142e1a1107d844b0940e0d8e6993b03bc74a276c4f496ea3f2c.png 2x, https://wott.io/assets/6b3f4b-da115e007b5f225052396b1d4c11879c7ae1e8c9d4e583340df32673c5e42e04.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now navigate to credentials and add a new credential with the following details:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Name = screenly
Key = login
Value = username:password
Owner = pi
Tags = screenly-pi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Where the Owner must be the Linux user running Screenly (so by default on a Raspberry Pi, &lt;code class=&quot;highlighter-rouge&quot;&gt;pi&lt;/code&gt;) and Key must be &lt;code class=&quot;highlighter-rouge&quot;&gt;login&lt;/code&gt; (or the credentials won’t be read). Value is the actual username and password of the login denoted by the single field &lt;code class=&quot;highlighter-rouge&quot;&gt;username:password&lt;/code&gt;. You can change this value to match your own criteria, but it’s fine for this example to leave it as is. Make sure as well that the Tags match whatever Tags you assigned the Pi earlier. The Name should be left as &lt;code class=&quot;highlighter-rouge&quot;&gt;screenly&lt;/code&gt; as this is how the config calls the credentials.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the config is automatically edited with the WoTT authentication details. You can change the Name value of &lt;code class=&quot;highlighter-rouge&quot;&gt;screenly&lt;/code&gt; if you wish, but note that this is how Screenly OSE will call WoTT’s credential information. So if you do change this name, then you will have to manually change the config file &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.screenly/screenly.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your credentials are now all set up. To download them onto the device, you will need to restart the WoTT Agent and the Screenly OSE server:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo service wott-agent restart
$ sudo service screenly-web restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There will now be a file on your Pi &lt;code class=&quot;highlighter-rouge&quot;&gt;screenly.json&lt;/code&gt;. 
&lt;strong&gt;Note:&lt;/strong&gt; it may take a few minutes for this to appear- especially on older Pi models,&lt;/p&gt;

&lt;p&gt;You can check the file exists by running the following command (if your user is &lt;code class=&quot;highlighter-rouge&quot;&gt;pi&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat /opt/wott/credentials/pi/screenly.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the certificate is downloaded, you should receive a response like so:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{&quot;screenly&quot;: &quot;username:password&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;securing-screenly-ose-management-page-access-with-wott-credentials&quot;&gt;Securing Screenly OSE management page access with WoTT credentials&lt;/h2&gt;

&lt;p&gt;You will now need to navigate to the Screenly OSE management page. This is the IP address displayed on the front of the Screenly OSE device (or is the &lt;code class=&quot;highlighter-rouge&quot;&gt;inet&lt;/code&gt; address when running the command &lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig&lt;/code&gt; in the device’s terminal).&lt;/p&gt;

&lt;p&gt;Navigate to Settings:&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Settings&quot; src=&quot;https://wott.io/assets/blog/screenly-schedule-939edcd959981451d7d13e85f3a6e8ba754fb03e94e68add5ece158b26a44297.png&quot; integrity=&quot;sha256-k57c2VmYFFHX0T6F86bounVPsD6U5ordXs4ViyakQpc=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/35f1a7-79bc663a47784acd6db5595539f1f6037dea9960802a2f4df4761f40eee3db18.png 2x, https://wott.io/assets/c82378-fd202793c7170c5d1c61bc89b457469cb14b914ee8eddbbb97a01edcd380c78e.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Scroll down the page and underneath ‘Authentication’ select ‘WoTT’ and save your settings.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;WoTT&quot; src=&quot;https://wott.io/assets/blog/screenly-wott-290945dab512182479adf0eaf98e858557e109489005924fcb60c6460d7b0488.png&quot; integrity=&quot;sha256-KQlF2rUSGCR5rfDq+Y6FhVfhCUiQBZJPy2DGRg17BIg=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/561ae0-b658d435893e8a7771a7090815c05429ff3b82c3568eb6c339b361a76abcab72.png 2x, https://wott.io/assets/052172-1047112833d800eb9601d5c846b16d62a61a7b2342d19486aac292a33d0b23ea.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You have now enabled the WoTT credentials on Screenly OSE. Test this out by trying to access the management page from another browser (the image example below is opened in Chrome) and you will be required to login with the credentials you specified above (in this case, &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;password&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Chrome&quot; src=&quot;https://wott.io/assets/blog/screenly-chrome-6dc710c2193e7bfe0387c3ba3c5ac842c3ca7c90766529757f93ab034afed64f.png&quot; integrity=&quot;sha256-bccQwhk+e/4Dh8O6PFrIQsPKfJB2ZSl1f5OrA0r+1k8=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/3fdef5-9741e594d15e8e895cc29bfb987725fdf7ee177858bd2821585caee2ca1f76b0.png 2x, https://wott.io/assets/c39b7a-9c458bc7f6721cd669a535dd3ab812da8daa5811b184cb9d1d67d1752c35fa6f.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If your credentials are correct, you will be successfully logged into the main Screenly management page and greeted by the Schedule Overview.&lt;/p&gt;

&lt;h2 id=&quot;closing-notes&quot;&gt;Closing Notes&lt;/h2&gt;

&lt;p&gt;You may be denied access in some of the terminal instances- to resolve this, use the &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; command where necessary.&lt;/p&gt;

&lt;p&gt;You can change the WoTT credentials as you wish, but note that data is fetched by &lt;code class=&quot;highlighter-rouge&quot;&gt;wott-agent service&lt;/code&gt; every 15 minutes, so for access to any immediate changes you implement you will need to restart the WoTT agent and server as before using&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo service wott-agent restart
$ sudo service screenly-web restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And that’s it, you have successfully used WoTT credentials to set up authentication for Screenly OSE.&lt;/p&gt;</content><author><name>Fiona McAllister</name></author><category term="tutorials" /><category term="Open Source" /><summary type="html">Using WoTT to secure access to Screenly</summary></entry><entry><title type="html">Why open source solutions are critical for IoT</title><link href="https://wott.io/blog/thoughts/2019/06/25/why-open-source-solutions-are-critical-for-IoT" rel="alternate" type="text/html" title="Why open source solutions are critical for IoT" /><published>2019-06-25T10:00:00+00:00</published><updated>2019-06-25T10:00:00+00:00</updated><id>https://wott.io/blog/thoughts/2019/06/25/why-open-source-solutions-are-critical-for-IoT</id><content type="html" xml:base="https://wott.io/blog/thoughts/2019/06/25/why-open-source-solutions-are-critical-for-IoT">&lt;p&gt;TL;DR IoT needs one ring to rule them all and it’s not a platform.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;No Image&quot; class=&quot;img-fluid&quot; src=&quot;https://wott.io/assets/blog/iot-monster-a50155cc3aca577bfecd98de974764a55eb1f286d9420cdb61674da6a277e742.png&quot; integrity=&quot;sha256-pQFVzDrKV3v+zZjel0dkpV6x8obZQgzbYWdNpqJ350I=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/bc774b-7ee6318975e5605d543509a836375b36976acef82e72a88a6790ca92b120cb4f.png 2x, https://wott.io/assets/681e0d-a1be036bf65afd45fd2cbe84fca236177d37e26a1acd5ecf1ec92d6b11307abb.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In my last post, I described the relevance of &lt;a href=&quot;https://wott.io/blog/thoughts/2019/06/24/why-open-source-is-critical-for-infosec&quot;&gt;open source security&lt;/a&gt;. For very different reasons, I will argue here that the internet of things (and cyber-physical systems in general) are in desperate need of open source software and tooling.  In short, proprietary technology is fragmenting the market, slowing development in an emerging field and killing some really exciting use cases.  Custom hardware, too many operating systems and cloud lock-in are the problem.&lt;/p&gt;

&lt;p&gt;Consider the challenge of building an IoT solution from end to end:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Custom boards are designed for economy of scale&lt;/li&gt;
  &lt;li&gt;Choose from a multitude of non-standard operating systems&lt;/li&gt;
  &lt;li&gt;Select a platform with high technical switching costs that is incompatible with other services&lt;/li&gt;
  &lt;li&gt;Roll your own certificates if they are supported by your platform&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The result is a unique system that is tied to a particular back-end infrastructure and likely incompatible with other ecosystems of devices.  It also requires cross-functional skills that one developer cannot master without years of experience.  The process is inefficient, expensive and error-prone - not to mention insecure.&lt;/p&gt;

&lt;p&gt;The opportunity to find interesting use cases beyond turning the lights on in my home while I’m out is hindered by the missing interoperability of the standard IoT development process.  If I switch from Spotify to Tidal, will it still integrate with my Bose speaker? Can I use either with Sonos? OK Google, where’s my iPhone? Did you order the Avocados from Ocado, Alexa?  I’m not endorsing any of these technologies, I am just saying that IoT makes it difficult to eat my Guacamole (not Avo/toast) and listen to the Black Album.  Though, check out the privacy conscious &lt;a href=&quot;https://blog.hackster.io/chatterbox-is-an-amazon-echo-like-device-that-protects-your-kids-privacy-dac95d4d3280&quot;&gt;Chatterbox&lt;/a&gt; for a great voice assistant alternative.&lt;/p&gt;

&lt;p&gt;While it is tempting to build the one proprietary platform that will monopolize all others, what IoT needs is common technologies that are accessible to all.  What better way to achieve this goal than with open-source tools?&lt;/p&gt;

&lt;p&gt;Consider an end to end solution like this:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Common mass produced, reusable, modular hardware - Raspberry Pi (Admit it, you’re already using them in real-world use cases - not just for prototyping.)&lt;/li&gt;
  &lt;li&gt;Common operating system - Linux&lt;/li&gt;
  &lt;li&gt;Common communication protocol - MQTT&lt;/li&gt;
  &lt;li&gt;Security - let’s be professional about it and use x509 certificates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The result would be a device that could be supported by multiple services and supported by many developers.  Documentation and support would be plentifully provided by the community.  Hardware costs could decrease from larger production runs to meet increased demand.&lt;/p&gt;

&lt;p&gt;Cheaper, simpler, secure and interoperable. I like the sound of that.&lt;/p&gt;

&lt;p&gt;Check back in to &lt;a href=&quot;https://wott.io/blog&quot;&gt;blog&lt;/a&gt;, join the &lt;a href=&quot;http://eepurl.com/ge0niv&quot;&gt;newsletter&lt;/a&gt; or follow on &lt;a href=&quot;https://www.twitter.com/wottsecurity&quot;&gt;twitter&lt;/a&gt;.&lt;/p&gt;</content><author><name>Al Esmail</name></author><category term="thoughts" /><category term="Open Source" /><summary type="html">TL;DR IoT needs one ring to rule them all and it’s not a platform.</summary></entry><entry><title type="html">Why open source is critical for InfoSec</title><link href="https://wott.io/blog/thoughts/2019/06/24/why-open-source-is-critical-for-infosec" rel="alternate" type="text/html" title="Why open source is critical for InfoSec" /><published>2019-06-24T10:00:00+00:00</published><updated>2019-06-24T10:00:00+00:00</updated><id>https://wott.io/blog/thoughts/2019/06/24/why-open-source-is-critical-for-infosec</id><content type="html" xml:base="https://wott.io/blog/thoughts/2019/06/24/why-open-source-is-critical-for-infosec">&lt;p&gt;TL;DR Proprietary security is a fresh cow pie hiding in the tall grass.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;Figure 1 - How I imagine decision fatigued CTOs see the world when speaking to proprietary security vendors. Can you spot the cow pie?&quot; class=&quot;img-fluid&quot; src=&quot;https://wott.io/assets/blog/cow-f652b4e6b3efce3e9c5657eda922f1804eeb66c8d57902b064a21e381756868f.jpg&quot; integrity=&quot;sha256-9lK05rPvzj6cVlftqSLxgE7rZsjVeQKwZKIeOBdWho8=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/8159a6-d993f408b99aef5908af5e2700f1ce5db0adb25b80fdd647c97e7924f8b10f53.jpg 2x, https://wott.io/assets/66a444-d5c3587a3d2a7ffa70bda1724bcfa14d904fd051b27e57039e77a732ece5d600.jpg 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 1 - How I imagine decision fatigued CTOs see the world when speaking to proprietary security vendors. Can you spot the cow pie?&lt;/p&gt;

&lt;p&gt;In a previous post, I advocated for the merits of &lt;a href=&quot;https://wott.io/blog/thoughts/2019/06/23/why-shift-left-security-is-relevant-for-iot&quot;&gt;DevSecOps&lt;/a&gt; and shift left security.  In this post, I will present our position on open source security vs. security by obfuscation (STO).  If you read the title and are familiar with the mid-western American expression &lt;a href=&quot;https://www.urbandictionary.com/define.php?term=Cow%20pie&quot;&gt;cow pie&lt;/a&gt;, you hopefully know where I am going.  If not, here’s a verbose description: fresh bovine excrement collapses under its own weight to form a flat cylindrical shape about the size of a pie and is well concealed by uncut grass.  It’ll really mess up your cowboy (or cowgirl) boots - get the picture?&lt;/p&gt;

&lt;p&gt;Let’s begin in 1883 when the Dutch-born cryptographer, Auguste Kerkchoffs articulated six design principles on &lt;a href=&quot;http://www.gutenberg.us/articles/shannon%27s_maxim&quot;&gt;La Cryptographie Militaire&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The system must be practically, if not mathematically, indecipherable;&lt;/li&gt;
  &lt;li&gt;It should not require secrecy, and it should not be a problem if it falls into enemy hands;&lt;/li&gt;
  &lt;li&gt;It must be possible to communicate and remember the key without using written notes, and correspondents must be able to change or modify it at will;&lt;/li&gt;
  &lt;li&gt;It must be applicable to telegraph communications;&lt;/li&gt;
  &lt;li&gt;It must be portable, and should not require several persons to handle or operate;&lt;/li&gt;
  &lt;li&gt;Lastly, given the circumstances in which it is to be used, the system must be easy to use and should not be stressful to use or require its users to know and comply with a long list of rules.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some of these are certainly redundant given advances in computation since the 19th century but the second principle remains and is referred to as Kerchoffs’ principle.  The principle was stated slightly differently (or perhaps restated) as “the enemy knows the system”, by American mathematician, Claude Shannon.  The latter is referred to as &lt;a href=&quot;http://netlab.cs.ucla.edu/wiki/files/shannon1949.pdf&quot;&gt;Shannon’s maxim&lt;/a&gt;. (An aside, I would be tickled to be the author of either a maxim or a principle but alas, such accolades have eluded me.)&lt;/p&gt;

&lt;p&gt;In searching for academic references to STO, I unfortunately was hard pressed to find even a postulate in favor of the practice.  I did not intend to run STO through the google test but the fourth organic result gives an indication of popular perception (don’t use it).  Though, Ross Patel does make a fair argument that &lt;a href=&quot;https://www.bcs.org/content/ConWebDoc/2788&quot;&gt;STO can enhance security&lt;/a&gt; in conjunction with other security methods.  He cites the example of network administrators placing sensitive services on non-standard ports to evade script kiddies and programs that exploit common vulnerabilities.&lt;/p&gt;

&lt;p&gt;It is a fair point that STO can indeed increase security if the means of obfuscation is consistently unique.  A metaphor to drive the point home - open source security is the safe in which you store the jewels; STO is the act of hiding the safe. Of course your safe is useless without a &lt;a href=&quot;https://wott.io/blog/thoughts/2019/06/22/wott-secures-the-internet-of-things&quot;&gt;strong password&lt;/a&gt;. That being said, a security company that offered a service to hide your safe behind the family portrait (and offered the same service to all its clients) is probably not offering a valuable service and likely why popular opinion does not favor the method. However, choosing to hide your safe somewhere non-obvious and random would indeed be a valuable addition to your security system.&lt;/p&gt;

&lt;p&gt;I would propose that security systems/methods/software that are used in many places or by many clients should adhere to Kerchoffs’ principle. Consider the following assumptions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As the number of users of a security system increases, the value of the assets protected by that system increases.&lt;/li&gt;
  &lt;li&gt;As  the value of assets protected by a system increases, the reward of compromising that system increases.&lt;/li&gt;
  &lt;li&gt;As the reward of compromising a system increases, the number of adversaries attacking the system increases.&lt;/li&gt;
  &lt;li&gt;As the number of adversaries attacking a system increases, the adversaries’ knowledge of that system increases.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Therefore, the enemy knowledge of a security system increases with the number of users.  I argue that widely used security systems must be completely open-source as these systems are designed to resist attack under complete enemy knowledge of its workings. Let it henceforth be known as &lt;em&gt;‘Esmail’s Postulate’&lt;/em&gt;. ;)&lt;/p&gt;

&lt;p&gt;Beyond adversary or enemy knowledge, we should consider the value added of public knowledge to a system.  Blackhats often work together by publishing their hacks on the dark web or Github (Mirai is on Github - I won’t link to it, but you can find it if you like). Others then contribute and build upon these tools furthering the capabilities.  Whitehats can mirror this collaborative behavior in releasing their tools to the commons and crowdsourcing audit, vulnerability disclosure and patches.&lt;/p&gt;

&lt;p&gt;To substantiate theory with practice, there are successful companies doing a great job with open source security:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/draios&quot;&gt;Sysdig&lt;/a&gt;: Unified cloud native visibility + security platform&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hashicorp/vault&quot;&gt;Hashicorp Vault&lt;/a&gt;: Secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/snyk/snyk&quot;&gt;Snyk&lt;/a&gt;: A developer-first solution that automates finding &amp;amp; fixing vulnerabilities in your dependencies&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/WoTTsecurity/agent&quot;&gt;WoTT&lt;/a&gt;: Plug and play cyber sec tools for IoT developers ;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What these companies have in common is that they are building developer tools.  We believe this is the best place to think about security - during development (&lt;a href=&quot;https://wott.ioblog/thoughts/2019/06/23/why-shift-left-security-is-relevant-for-iot&quot;&gt;link to shift left security&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;To conclude, security through obfuscation is a single piece to consider in building a strong system.  The &lt;em&gt;plat de resistance&lt;/em&gt; in your security system should be open source, resilient in enemy hands and supported by crowdsourced audit.&lt;/p&gt;

&lt;p&gt;Join the &lt;a href=&quot;http://eepurl.com/ge0niv&quot;&gt;newsletter&lt;/a&gt; or follow on &lt;a href=&quot;https://www.twitter.com/wottsecurity&quot;&gt;twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Want to troll me? Comments below or &lt;a href=&quot;https://www.twitter.com/wottsecurity&quot;&gt;twitter&lt;/a&gt;.&lt;/p&gt;</content><author><name>Al Esmail</name></author><category term="thoughts" /><category term="Open Source" /><summary type="html">TL;DR Proprietary security is a fresh cow pie hiding in the tall grass.</summary></entry><entry><title type="html">Why shift-left security is relevant for IoT</title><link href="https://wott.io/blog/thoughts/2019/06/23/why-shift-left-security-is-relevant-for-iot" rel="alternate" type="text/html" title="Why shift-left security is relevant for IoT" /><published>2019-06-23T10:00:00+00:00</published><updated>2019-06-23T10:00:00+00:00</updated><id>https://wott.io/blog/thoughts/2019/06/23/why-shift-left-security-is-relevant-for-iot</id><content type="html" xml:base="https://wott.io/blog/thoughts/2019/06/23/why-shift-left-security-is-relevant-for-iot">&lt;p&gt;TL;DR Cyber is best handled by developers with big, bulging…brains.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://media.giphy.com/media/lQaO9Cf50zlM4/giphy.gif&quot; alt=&quot;Natalie Portman&quot; /&gt;
Figure 1 - Cyber is sexier than a Harvard trained, Academy Award winning actress.&lt;/p&gt;

&lt;p&gt;In our &lt;a href=&quot;https://wott.io/blog/news/2019/06/20/why-we-are-doing-what-we-do&quot;&gt;first blog post&lt;/a&gt;, I articulated that we are strong proponents of shift-left security.  The idea that security should be incorporated as early as possible during application and infrastructure development.  In this post, I will explain why we feel that developers are in a strong position to improve security posture and why it’s more efficient for them to be involved in the solution.&lt;/p&gt;

&lt;p&gt;Firstly, let me say that I think cyber is sexy - well, sexy in a very particular way.  It’s easy to lose sight of it in Whatsapp headlines or unflattering Julian Assange photos.  Normally though, the protagonist hacker is presented to us as odd in social disposition but powerful in IQ, perception and virtue - think Rami Malek playing Eliot Alderson - leader of &lt;em&gt;fsociety&lt;/em&gt;. Sexy, right?&lt;/p&gt;

&lt;p&gt;The cyber game is between adversaries playing offense and defense, like high stakes cat and mouse.  To get a sense of the calibre of minds playing in this battle of wits, consider the complexity of &lt;a href=&quot;https://www.youtube.com/watch?v=z1-eH3NJJX0&quot;&gt;zero knowledge science&lt;/a&gt;, the magic math that goes into it and then trying to find a way around it.  It’s a hard game and a dynamic one at that. I feel bad for anyone that thinks they are on the sidelines.  We’re all playing the cyber game whether we realize it or not.&lt;/p&gt;

&lt;p&gt;Given this high stakes sport is played by crafty and pragmatic geniuses, the best way you to protect yourself is to put your best line on the court.  Who better than your own developers that know the ins and outs of their own code?  Developers strive for efficiency, utility and happen to have big, bulging - &lt;em&gt;brains&lt;/em&gt;.  Moreover, as application development and operations have merged into DevOps to bring about agile methods and higher velocity, it has become nearly impossible for security teams to keep up.  To solve the problem, merge security mindset with DevOps to spawn DevSecOps (yes, it’s a mouthful but I already mentioned that size matters in this sport).&lt;/p&gt;

&lt;p&gt;Let’s define &lt;a href=&quot;https://opensource.com/article/19/1/what-devsecops&quot;&gt;DevSecOps&lt;/a&gt; a little more clearly.  It is the prioritization of security practices by developers and/or incorporating a security team member into product teams.  The current siloed nature of security incentivizes developers to work around it or push accountability to a different team.  Either way, the result is a less efficient, uncollaborative and ultimately less secure system.  The incorporation of security thinking into the earliest stages of design reduces the &lt;a href=&quot;https://www.researchgate.net/figure/Cost-to-fix-at-different-phases-of-development_fig1_301789336&quot;&gt;cost of fixing flaws&lt;/a&gt; by at least 5x, according to NIST.  In effect, shift left security is far cheaper than the alternative - waiting for vulnerabilities to be pointed out after code is committed (hopefully by a whitehat rather than a blackhat).  In a world where you are in an ongoing war with the aforementioned crafty genius adversaries, it would behoove you to be efficient with your resources.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;The NIST says so. Prove them wrong if you want&quot; class=&quot;img-fluid&quot; src=&quot;https://wott.io/assets/blog/nist-f971fcc531c0f7d3a08b593d29dde670f2859588e61ccd3ef9ffd333cf486d15.png&quot; integrity=&quot;sha256-+XH8xTHA99Ogi1k9Kd3mcPKFlYjmHM0++f/TM89IbRU=&quot; crossorigin=&quot;anonymous&quot; srcset=&quot;https://wott.io/assets/5697f2-3169e92896580ab43e8810879fcdeaa67e1dc4b36c622a1d42b8570f845daa31.png 2x, https://wott.io/assets/3bcc4b-d62ef16ccb231b7b91c008c52d49d39f808d372512b4fe714b6b513b6a42d200.png 1x&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 4 - The NIST says so. Prove them wrong if you want. I don’t care.&lt;/p&gt;

&lt;p&gt;In considering end-points, DevSecOps or shift-left security introduces another important concept: &lt;em&gt;secure by design&lt;/em&gt;.  Presently, CISOs turn to perimeter security solutions (firewalls and networking monitoring) to protect devices.  Though, the latest thinking proposes making the assumption that closed networks have already been compromised and are hostile &lt;a href=&quot;https://www.oreilly.com/library/view/zero-trust-networks/9781491962183/ch01.html&quot;&gt;Zero Trust&lt;/a&gt;. I will take this concept further in a future post and consider remote and open networks.  Given the assumption that networks are hostile, we must build security into the device itself.  The only way to do that is during design and so we shift security left.&lt;/p&gt;

&lt;p&gt;To hammer home the point, let’s use simile (not metaphor): network monitoring is like snipers on rooftops and secure by design is like bulletproof windows.  It’s simply not possible for snipers to see everything unless you have enough of them.  Eventually, these angry looking gunmen are bound to interfere with day to day life.  Bulletproof windows are transparent or seamless - quietly protecting you from danger.  Yes, windows can always be broken but it takes much bigger guns, which far fewer people have access to in most parts of the world.  This effectively reduces the size of the threat space or threat community.  If you’re only worried about state-sponsored cyber attacks, I’d say you’re doing pretty well.  I don’t advocate removing the snipers, but I do suggest adding additional layers of security in case one system fails (or ‘defense in depth’ if you want it in corporate speak).  In the case of open networks, secure by design is the &lt;em&gt;only&lt;/em&gt; option.&lt;/p&gt;

&lt;p&gt;To conclude, cyber is sexy and the only obvious thing to do is to bring in the A-team and involve developers in security decision-making. We know you’re packing heat in those brains of yours, girls and boys. Get off the bench, get in the game, do your part, be part of the solution, be a whitehat, etcetera, etcetera, etcetera.&lt;/p&gt;

&lt;p&gt;I claim that open networks are an important use case to cover. Will cover that in a future blog - Check back in to the &lt;a href=&quot;https://wott.io/blog&quot;&gt;blog&lt;/a&gt;, join the &lt;a href=&quot;http://eepurl.com/ge0niv&quot;&gt;newsletter&lt;/a&gt; or follow on &lt;a href=&quot;https://twitter.com/wottsecurity&quot;&gt;twitter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Want to troll me? Comments below or &lt;a href=&quot;https://www.twitter.com/wottsecurity&quot;&gt;twitter&lt;/a&gt;&lt;/p&gt;</content><author><name>Al Esmail</name></author><category term="thoughts" /><category term="Open Source" /><summary type="html">TL;DR Cyber is best handled by developers with big, bulging…brains.</summary></entry></feed>